// vi: sw=4 ts=4:

/*
------------------------------------------------------------------------------------------------
	Mnemonic:	ostack_hosts
	Abstract:	Functions to support getting some kind of list of hosts:
					
	Date:		16 December 2013
	Author:		E. Scott Daniels
	Mods:		13 Aug 2014 - Changes to List_hosts() to allow multiple types to be supplied,
					and to work with the network centric list host function now that nova
					seems decoupled from the network information.
				04 Nov 2014 - Changes to better support gizzley.
				04 Dec 2014 - Now supports getting a list of physical hosts that are "enabled"
					and up (which we assume might not be down for maintenance).
------------------------------------------------------------------------------------------------
*/

package ostack

import (
	"bytes"
	"encoding/json"
	"fmt"
	"strings"
	//"os"
)

// ------------- structs that are used to unbundle the json auth response data -------------------

// this is based on data snarfed from doc: http://api.openstack.org/api-ref-compute.html
//

// ---------------- generated by os-hypervisors get ----------------------------
type ost_hypervisor struct {
	Hypervisor_hostname string
	Id	int
}

type ost_hypervisor_resp struct {
	Hypervisors []ost_hypervisor
}

// ------------------------------------------------------------------------------
type ost_hyp_service struct {
	Host string
	Id int
}

type ost_hyp_details struct {
	//cpu_info "?",
	//current_workload 0,
	//disk_available_least null,
	//free_disk_gb 1028,
	//free_ram_mb 7680,
	Hypervisor_hostname string
	Hypervisor_type string
	//hypervisor_version 1,
	//id 1,
	//local_gb 1028,
	//local_gb_used 0,
	//memory_mb 8192,
	//memory_mb_used 512,
	//running_vms 0,
	Service	ost_hyp_service
	//vcpus 1,
	//vcpus_used 0
}

type ost_hyp_details_resp struct {
	Hypervisors []ost_hyp_details
}
// -- internal helper stuff -----------------------------------------------------

/*
	Creates a map of various openstack service types that can be used to easily
	match a type name returned by openstack to a desired type bit mask supplied
	by the user. Seems that different strings come back depending on the request
	so this should provide a map from all possible names to the smaller set of
	constants this package provides to the user.
*/
func gen_svc_match_map( ) ( match_type map[string]int ) {

	match_type = make( map[string]int )

	match_type["compute"] = COMPUTE
	match_type["nova-compute"] = COMPUTE
	match_type["scheduler"] = SCHEDULE
	match_type["nova-scheduler"] = SCHEDULE
	match_type["network"] = NETWORK
	match_type["cert"] = CERT
	match_type["nova-cert"] = CERT
	match_type["cells"] = CELLS
	match_type["conductor"] = CONDUCTOR
	match_type["nova-conductor"] = CONDUCTOR
	match_type["consoleauth"] = AUTH
	match_type["nova-consoleauth"] = AUTH

	return
}

// ------------------------------------------------------------------------------

/*
	Generates a pointer to a string containing a space separated list of physical host names
	that are associated with the type(s) passed in. Htype is one or more of the following
	types OR'd together if desired:
		NETWORK, COMPUTE, SCHEDULE, AUTH, CONDUCTOR, CELLS, and CERT

	Duplicates host names, hosts that might have different functions, are removed from the
	list. The credentials associated with the object must have admin privlidges or odd results
	(an empty list or nil pointer) will result.
*/
func (o *Ostack) List_hosts( htype int ) ( hlist *string, err error ) {
	var (
		host_data	generic_response	// "root" of the response goo after pulling out of json format
		jdata	[]byte					// raw json response data
		seen	map[string]bool			// used to weed duplicates
	)

	hlist = nil						// if we error, ensure nil list returned
	err = nil;
	s := ""							// tmp string to build list in
	sep := ""						// separater between list elements, nothing for first

	seen = make( map[string]bool )
	match_type := gen_svc_match_map()	// make matching matrix based on expected ostack strings

	err = o.Validate_auth()						// reauthorise if needed
	if err != nil {
		return
	}

	if o.chost == nil || *o.chost == "" {
		err = fmt.Errorf( "no chost url for ostack struct: %s", o.To_str( ) )
		return
	}


	if  htype & NETWORK != 0 {							// since networking is a separate request to neutron, make only if user set
		if o.nhost == nil || *o.nhost == "" {
			err = fmt.Errorf( "no nhost url for ostack struct: %s", o.To_str( ) )
			return
		}

		hlist, seen, err = o.List_net_hosts( seen, true ) 	
		if *hlist == "" {								// no network hosts, can't be, so we assume it's pre neutron
			hlist, seen, err = o.List_net_hosts( seen, false ) 	
		}
		if htype == NETWORK || err != nil  {			// when only network is requested, we can short out here.
			return
		}

		s = *hlist										// seed for the call to nova
		if len( seen ) > 0 {							// if something found in the list, sep is now space (bug fix 2014.08.30)
			sep = " "
		}
	}

	jdata = nil
	body := bytes.NewBufferString( "" )

	url := fmt.Sprintf( "%s/os-hosts", *o.chost )		// tennant id is built into chost
    dump_url( "xhosts", 10, url )
	jdata, _, err = o.Send_req( "GET",  &url, body );

	if err != nil {
		return
	}
	dump_json( "hosts", 10, jdata )

	err = json.Unmarshal( jdata, &host_data )			// unpack the json into response struct
	if err != nil {
		dump_json(  fmt.Sprintf( "list_hosts: unpack err: %s\n", err ), 30, jdata )
		return
	}

	for k := range host_data.Hosts {
		if  match_type[host_data.Hosts[k].Service] & htype != 0 {				// this type requested on call
			if !seen[host_data.Hosts[k].Host_name] {
				seen[host_data.Hosts[k].Host_name] = true
				s += sep + host_data.Hosts[k].Host_name
				sep = " "
			}
		}
	}

	hlist = &s
	return
}

/*
	Lists only hosts associated with services which _might_ just differ from the hosts
	listed by os-hosts.  Certainly the information returned by  os-hosts has less
	information (running or not seems unimportant etc.), so this list might be more
	useful as it will return only those hosts that we _think_ are actually alive and
	well (which might not be true since the state seems based on the openstack software
	running on the phyiscal host and not the state of the host itself). 

	Returns a space separated list of host names as a string.
*/
func (o *Ostack) List_enabled_hosts( htype int ) ( hlist *string, err error ) {
	var (
		resp_data	generic_response	// "root" of the response goo after pulling out of json format
		jdata	[]byte					// raw json response data
		seen	map[string]bool			// used to weed duplicates
	)

	hlist = nil						// if we error, ensure nil list returned
	err = nil;
	s := ""							// tmp string to build list in
	sep := ""						// separater between list elements, nothing for first

	seen = make( map[string]bool )
	match_type := gen_svc_match_map()	// make matching matrix based on expected ostack strings

	err = o.Validate_auth()						// reauthorise if needed
	if err != nil {
		return
	}

	if o.chost == nil || *o.chost == "" {
		err = fmt.Errorf( "no chost url for ostack struct: %s", o.To_str( ) )
		return
	}


	if  htype & NETWORK != 0 {							// since networking is a separate request to neutron, make only if user set
		if o.nhost == nil || *o.nhost == "" {
			err = fmt.Errorf( "no nhost url for ostack struct: %s", o.To_str( ) )
			return
		}

		hlist, seen, err = o.List_net_hosts( seen, true ) 	
		if *hlist == "" {								// no network hosts, can't be, so we assume it's pre neutron
			hlist, seen, err = o.List_net_hosts( seen, false ) 	
		}
		if htype == NETWORK || err != nil  {			// when only network is requested, we can short out here.
			return
		}

		s = *hlist										// seed for the call to nova
		if len( seen ) > 0 {							// if something found in the list, sep is now space (bug fix 2014.08.30)
			sep = " "
		}
	}

	jdata = nil
	body := bytes.NewBufferString( "" )

	url := fmt.Sprintf( "%s/os-services", *o.chost )		// tennant id is built into chost
    dump_url( "xhosts", 10, url )
	jdata, _, err = o.Send_req( "GET",  &url, body );

	if err != nil {
		return
	}
	dump_json( "hosts", 10, jdata )

	err = json.Unmarshal( jdata, &resp_data )			// unpack the json into response struct
	if err != nil {
		dump_json(  fmt.Sprintf( "list_hosts: unpack err: %s\n", err ), 30, jdata )
		return
	}

	if resp_data.Error != nil {
		err = fmt.Errorf( "%s", resp_data.Error );
		return
	}

	if resp_data.Forbidden != nil {
		err = fmt.Errorf( "%s", resp_data.Forbidden );
		return
	}

	for k := range resp_data.Services {
		bin := strings.ToLower( resp_data.Services[k].Binary )
		if  match_type[bin] & htype != 0 {								// this type requested on call
			if !seen[resp_data.Services[k].Host] &&
				strings.ToLower( resp_data.Services[k].State ) == "up" &&
				strings.ToLower( resp_data.Services[k].Status ) == "enabled" {

				seen[resp_data.Services[k].Host] = true
				s += sep + resp_data.Services[k].Host
				sep = " "
			}
		}
	}

	hlist = &s
	return
}

/*
	Creates a map of hypervisor IDs to host names
*/
func (o *Ostack) Mk_hyp2host(  ) ( hmap map[int]*string, err error ) {
	var (
		jdata	[]byte				// raw json response data
		hyp_data	ost_hypervisor_resp
	)

	hmap = nil
	err = nil;

	err = o.Validate_auth()						// reauthorise if needed
	if err != nil {
		return
	}

	jdata = nil
	body := bytes.NewBufferString( "" )

	url := fmt.Sprintf( "%s/os-hypervisors", *o.chost )		// tennant id is built into chost
	jdata, _, err = o.Send_req( "GET",  &url, body );

	if err != nil {
		return
	}

	err = json.Unmarshal( jdata, &hyp_data )			// unpack the json into response struct
	if err != nil {
		//fmt.Fprintf( os.Stderr, "ostack/Mk_hyp2host: unable to unpack json: %s\n", err )		//TESTING
		//fmt.Fprintf( os.Stderr, "offending_json=%s\n", jdata )
		dump_json(  fmt.Sprintf( "Mk_hyp2host: unpack err: %s\n", err ), 30, jdata )
		return
	}

	hmap = make( map[int]*string )
	for k := range hyp_data.Hypervisors {
		dup_str := hyp_data.Hypervisors[k].Hypervisor_hostname
		hmap[hyp_data.Hypervisors[k].Id] = &dup_str
	}

	return
}
