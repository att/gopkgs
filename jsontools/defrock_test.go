// vi: sw=4 ts=4:
/*
 ---------------------------------------------------------------------------
   Copyright (c) 2013-2015 AT&T Intellectual Property

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 ---------------------------------------------------------------------------
*/


package jsontools_test

import (
	"fmt"
	"testing"
	"os"

	"github.com/att/gopkgs/jsontools"
)

/*
	Returns true if there are any escape characters in the string.
*/
func has_escapes( s string ) ( bool ) {
	for _, c := range s {
		if c == '\\' {
			return true
		}
	}

	return false
}

func TestDefrock( t *testing.T ) {
	var (
		jstring	string
		jbytes []byte
	)

	fmt.Fprintf( os.Stderr, "===== start defrock testing ======\n\n" )

	// this is similar to an openstack oslo message which feels the need to embed json as a string (network_info in tis case)
	// the resulting refrock should be valid json and should not have any escapes
	jstring = "{\"_context_domain\": null, \"_msg_id\": \"342f25641ede44f381c4222ca93ff018\", \"_context_quota_class\": null, \"_context_read_only\": false, \"_context_request_id\": \"req-840657d6-c568-4b03-aebc-005d7c0e6fa4\", \"_context_service_catalog\": [], \"args\": {\"instance\": {\"vm_state\": \"active\", \"availability_zone\": \"nova\", \"terminated_at\": null, \"ephemeral_gb\": 0, \"instance_type_id\": 3, \"user_data\": null, \"cleaned\": false, \"vm_mode\": null, \"deleted_at\": null, \"reservation_id\": \"r-loov99le\", \"id\": 2125, \"security_groups\": [], \"disable_terminate\": false, \"root_device_name\": \"/dev/vda\", \"display_name\": \"jd-tmp\", \"uuid\": \"bc353bd2-0f02-46b7-8366-51879cf820f5\", \"default_swap_device\": null, \"info_cache\": {\"instance_uuid\": \"bc353bd2-0f02-46b7-8366-51879cf820f5\", \"deleted\": false, \"network_info\": [{\"profile\": {}, \"ovs_interfaceid\": \"ebf58f66-7f56-4111-bdd6-6f81954972cd\", \"preserve_on_delete\": false, \"network\": {\"bridge\": \"br-int\", \"label\": \"cloudqos-private\", \"meta\": {\"injected\": false, \"tenant_id\": \"65c3e5ee5ee0428caa5e5275c58ead61\"}, \"id\": \"e174ae6a-ef11-45e4-b888-add340e98c4f\", \"subnets\": [{\"ips\": [{\"meta\": {}, \"type\": \"fixed\", \"floating_ips\": [], \"version\": 4, \"address\": \"10.7.1.173\"}], \"version\": 4, \"meta\": {\"dhcp_server\": \"10.7.0.2\"}, \"dns\": [{\"meta\": {}, \"type\": \"dns\", \"version\": 4, \"address\": \"135.207.177.11\"}, {\"meta\": {}, \"type\": \"dns\", \"version\": 4, \"address\": \"135.207.179.11\"}], \"routes\": [], \"cidr\": \"10.7.0.0/16\", \"gateway\": {\"meta\": {}, \"type\": \"gateway\", \"version\": 4, \"address\": \"10.7.0.1\"}}]}, \"devname\": \"tapebf58f66-7f\", \"qbh_params\": null, \"vnic_type\": \"normal\", \"meta\": {}, \"details\": {\"port_filter\": true, \"ovs_hybrid_plug\": true}, \"address\": \"fa:16:3e:43:28:54\", \"active\": true, \"type\": \"ovs\", \"id\": \"ebf58f66-7f56-4111-bdd6-6f81954972cd\", \"qbg_params\": null}], \"created_at\": \"2016-06-06T22:24:36.000000\", \"deleted_at\": null, \"updated_at\": \"2016-06-06T22:41:44.000000\"}, \"hostname\": \"jd-tmp\", \"launched_on\": \"qos101\", \"display_description\": \"jd-tmp\", \"key_data\": \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCc3+Qt64MiXHeCoIIbeLvwUYrm2vxXRyv5qyan+J/51hYfu2myVJdV+1X0vnpg27ZgdmgzrHRvvRExG9jjtI/+TvAQ3ZQZkvxxGARl6kP+xAYyUvBvyrzEqTzb7BPpN7Nr4K2Fv0ZNW0uTByQuCXR7IrfuX+0B5aTYVSDNVh2vGDLZ815FOAEUsJsV9LV4jg26MbuePwahGf0OsbiTAfgLyxGbiUb3vl6Yvzojd/GvcWcaLGw4OO7DvSbNMjXq8e6bOuFqBVaAxaPSvvyP1LKrAXQjuCDTCxAH255vbVYTpfGedeGzWF7mTZNb5NQAczbZkYdEHz8NbVmF7sRQA69L Generated by Nova\", \"deleted\": false, \"power_state\": 1, \"default_ephemeral_device\": null, \"progress\": 0, \"project_id\": \"65c3e5ee5ee0428caa5e5275c58ead61\", \"launched_at\": \"2016-06-06T22:24:53.000000\", \"config_drive\": \"\", \"node\": \"qos101\", \"ramdisk_id\": \"\", \"access_ip_v6\": null, \"access_ip_v4\": null, \"kernel_id\": \"\", \"key_name\": \"demo\", \"updated_at\": \"2016-06-06T22:24:53.000000\", \"host\": \"qos101\", \"root_gb\": 40, \"user_id\": \"1702902d510646838cff9303c7ff16ce\", \"task_state\": null, \"shutdown_terminate\": false, \"cell_name\": null, \"ephemeral_key_uuid\": null, \"locked\": false, \"name\": \"instance-0000084d\", \"created_at\": \"2016-06-06T22:24:36.000000\", \"locked_by\": null, \"launch_index\": 0, \"memory_mb\": 4096, \"vcpus\": 2, \"image_ref\": \"e19aa5bf-bb11-4e39-a706-0fd438beee50\", \"architecture\": null, \"auto_disk_config\": false, \"os_type\": null, \"scheduled_at\": null}}, \"_unique_id\": \"8b5f263f7b5a4642acd47861ee53222d\", \"_context_resource_uuid\": null, \"_context_instance_lock_checked\": false, \"_context_user\": null, \"_context_user_id\": null, \"_context_project_name\": null, \"_context_read_deleted\": \"no\", \"_context_user_identity\": \"- - - - -\", \"_reply_q\": \"reply_0d0c2a1003ac41c2b2d3ad0e0de76d1c\", \"_context_auth_token\": null, \"_context_show_deleted\": false, \"_context_tenant\": null, \"_context_roles\": [], \"_context_is_admin\": true, \"version\": \"2.0\", \"_context_project_id\": null, \"_context_project_domain\": null, \"_context_timestamp\": \"2017-06-05T19:32:34.641731\", \"_context_user_domain\": null, \"_context_user_name\": null, \"method\": \"get_ec2_ids\", \"_context_remote_address\": null}"

	//fmt.Fprintf( os.Stderr, ">>>> original\n %s\n\n", jstring )

	jbytes = []byte( jstring );
	jif, err := jsontools.Defrock_2_jif( jbytes[:] )

	if err != nil {
		fmt.Fprintf( os.Stderr, "errors unpacking json: %s    [FAIL]\n", err )
		t.Fail()
		return
	}

	if jif == nil {
		fmt.Fprintf( os.Stderr, "no error, but jif was nil" )
		t.Fail();
		return
	}
	fmt.Fprintf( os.Stderr, "[OK]  defrocked without errors\n" )

	// --- refrock the resulting map from jstring which should produce a valid json string, but without the bleeding escaped bits of json
	s := jsontools.Frock_jmap( jif )
	fmt.Fprintf( os.Stderr, "frocked output:\n%s\n\n", s )
	fmt.Fprintf( os.Stderr, "\nvalidate above output at https://jsonlint.com/ \n" )
	if has_escapes( s ) {
		fmt.Fprintf( os.Stderr, "[FAIL] there are unexpected escapes in the resulting json string\n" )
		t.Fail( )
	}

	s, err = jsontools.Refrock( jstring )		// does the same thing as above via the Refrock() funciton
	if err != nil {
		fmt.Fprintf( os.Stderr, "[FAIL] refrock attempt failed: %s", err )
		t.Fail()
	} else  {
		fmt.Fprintf( os.Stderr, "refrocked output:\n%s\n\n", s )
		fmt.Fprintf( os.Stderr, "\nvalidate above output at https://jsonlint.com/ \n" )
		if has_escapes( s ) {
			fmt.Fprintf( os.Stderr, "[FAIL] there are unexpected escapes in the resulting json string\n" )
			t.Fail( )
		}
	}

	fmt.Fprintf( os.Stderr, "===== end defrock testing ======\n\n" )
}

